一般来说，总是把类的属性定义为private，这更符合现实的逻辑。但是， 对属性的读取和赋值操作是非常频繁的，因此在PHP5中，预定义了两个函数”__get()”和”__set()”来获取和赋值其属性，以及检查属性的”__isset()”和删除属性的方法”__unset()”。

上一节中，我们为每个属性做了设置和获取的方法，在PHP5中给我们提供了专门为属性设置值和获取值的方法，”__set()”和“__get()”这两个方法，这两个方法不是默认存在的， 而是我们手工添加到类里面去的，像构造方法(__construct())一样，类里面添加了才会存在，可以按下面的方式来添加这两个方法，当然也可以按个人的风格来添加：

```
<?php
// __get()方法用来获取私有属性
function __get($property_name) {
    if (isset($this->$property_name)) {
        return ($this->$property_name);
    } else {
        return (NULL);
    }
}
 
// __set()方法用来设置私有属性
function __set($property_name, $value) {
    $this->$property_name = $value;
}
```

**__get()方法**：这个方法用来获取私有成员属性值的，有一个参数， 参数传入你要获取的成员属性的名称，返回获取的属性值， 这个方法不用我们手工的去调用， 是在直接获取私有属性的时候自动调用的。因为私有属性已经被封装上了，是不能直接获取值的（比如：”echo $p1->name” 这样直接获取是错误的），但是如果你在类里面加上了这个方法，在使用”echo $p1->name” 这样的语句直接获取值的时候就会自动调用__get($property_name)方法，将属性name传给参数$property_name，通过这 个方法的内部执行，返回我们传入的私有属性的值。

**__set()方法**：这个方法用来为私有成员属性设置值的， 有两个参数，第一个参数为你要为设置值的属性名，第二个参数是要给属性设置的值，没有返回值。这个方法同样不用我们手工去调用，是在直接设置私有属性值的 时候自动调用的，同样属性私有的已经被封装上了， 如果没有__set()这个方法，是不允许的， 比如：”$this->name=’zhangsan’，这样会出错，但是如果你在类里面加上了__set($property_name, $value)这个方法，在直接给私有属性赋值的时候，就会自动调用它，把属性比如name传给$property_name， 把要赋的值”zhangsan”传给$value，通过这个方法的执行，达到赋值的目的， 为了不传入非法的值， 还可以在这个方法给做一下判断。代码如下：

```
<?php
class Person {
    // 下面是人的成员属性， 都是封装的私有成员
    private $name;      //人的名子
    private $sex;       //人的性别
    private $age;       //人的年龄
 
    // __get()方法用来获取私有属性
    function __get($property_name) {
        echo "在直接获取私有属性值的时候，自动调用了这个__get()方法<br />";
        if (isset($this->$property_name)) {
            return ($this->$property_name);
        } else {
            return NULL;
        }
    }
 
    // __set()方法用来设置私有属性
    function __set($property_name, $value) {
        echo "在直接设置私有属性值的时候，自动调用了这个__set()方法为私有属性赋值<br />";
        $this->$property_name = $value;
    }
}
 
$p1 = new Person();
 
// 直接为私有属性赋值的操作， 会自动调用__set()方法进行赋值
$p1->name = "张三";
$p1->sex = "男";
$p1->age = 20;
 
// 直接获取私有属性的值， 会自动调用__get()方法，返回成员属性的值
echo "姓名：" . $p1->name . "<br />";
echo "性别：" . $p1->sex . "<br />";
echo "年龄：" . $p1->age . "<br />";
?>
```

程序执行结果：

```
在直接设置私有属性值的时候，自动调用了这个__set()方法为私有属性赋值
在直接设置私有属性值的时候，自动调用了这个__set()方法为私有属性赋值
在直接设置私有属性值的时候，自动调用了这个__set()方法为私有属性赋值
在直接获取私有属性值的时候，自动调用了这个__get()方法
姓名：张三
在直接获取私有属性值的时候，自动调用了这个__get()方法
性别：男
在直接获取私有属性值的时候，自动调用了这个__get()方法
年龄：20
```

以上代码如果不加上__get()和__set()方法，程序就会出错，因为不能在类的外部操作私有成员，而上面的代码是通过自动调用__get()和__set()方法来帮助我们直接存取封装的私有成员的。

**__isset() 方法**：在看这个方法之前我们看一下“isset()”函数的应用，isset()是测定变量是否设定用的函数，传入一个变量作为参数，如果传入的变量存在则传回true，否则传回false。那么如果在一个对象外面使用“isset()”这个函数去测定对象里面的成员是否被设定可不可以用它呢？分两种情况，如果对象里面成员是公有的，我们就可以使用这个函数来测定成员属性，如果是私有的成员属性，这个函数就不起作用了，原因就是因为私有的被封装了，在外部不可见。那么我们就不可以在对象的外部使用“isset()”函数来测定私有成员属性是否被设定了呢？可以，你只要在类里面加上一个“__isset()”方法就可以了，当在类外部使用”isset()”函数来测定对象里面的私有成员是否被设定时，就会自动调用类里面的“__isset()”方法了帮我们完成这样的操作，“__isset()”方法也可以做成私有的。你可以在类里面加上下面这样的代码就可以了：

```
private function __isset($nm) {
    echo "当在类外部使用isset()函数测定私有成员$nm时，自动调用<br />";
    return isset($this->$nm);
}
```

**__unset()方法**：看这个方法之前呢，我们也先来看一下“unset()”这个函数，“unset()”这个函数的作用是删除指定的变量且传回true，参数为要删除的变量。那么如果在一个对象外部去删除对象内部的成员属性用“unset()”函数可不可以呢，也是分两种情况，如果一个对象里面的成员属性是公有的，就可以使用这个函数在对象外面删除对象的公有属性，如果对象的成员属性是私有的，我使用这个函数就没有权限去删除，但同样如果你在一个对象里面加上“__unset()”这个方法，就可以在对象的外部去删除对象的私有成员属性了。在对象里面加上了“__unset()”这个方法之后，在对象外部使用“unset()”函数删除对象内部的私有成员属性时，自动调用“__unset()”函数来帮我们删除对象内部的私有成员属性，这个方法也可以在类的内部定义成私有的。在对象里面加上下面的代码就可以了：

```
private function __unset($nm) {
    echo "当在类外部使用unset()函数来删除私有成员时自动调用的<br />";
    unset($this->$nm);
}
```

我们来看一个完整的实例：

```
<?php
class Person {
    // 下面是人的成员属性
    private $name;      // 人的名子
    private $sex;       // 人的性别
    private $age;       // 人的年龄
 
    // __get()方法用来获取私有属性
    private function __get($property_name) {
        if (isset($this->$property_name)) {
            return ($this->$property_name);
        } else {
            return NULL;
        }
    }
 
    // __set()方法用来设置私有属性
    private function __set($property_name, $value) {
        $this->$property_name = $value;
    }
 
    // __isset()方法
    private function __isset($nm) {
        echo "isset()函数测定私有成员时，自动调用<br />";
        return isset($this->$nm);
    }
 
    //__unset()方法
    private function __unset($nm) {
        echo "当在类外部使用unset()函数来删除私有成员时自动调用的<br />";
        unset($this->$nm);
    }
}
 
$p1 = new Person();
$p1->name = "this is a person name";
 
// 在使用isset()函数测定私有成员时，自动调用__isset()方法帮我们完成，返回结果为true
echo var_dump(isset($p1->name)) . "<br >";
echo $p1->name . "<br />";
 
// 在使用unset()函数删除私有成员时，自动调用__unset()方法帮我们完成，删除name私有属性
unset($p1->name);
 
// 已经被删除了，所这行不会有输出
echo $p1->name;
?>
```

输出结果为：

```
isset()函数测定私有成员时，自动调用
boolean true
this is a person name
当在类外部使用unset()函数来删除私有成员时自动调用的
isset()函数测定私有成员时，自动调用
```

__set()、__get()、__isset()、__unset() 这四个方法都是我们添加到对象里面的，在需要时自动调用的，来完成在对象外部对对象内部私有属性的操作。

==最后补充说明：==

1、__set()， __get() 是专门为类的私有属性（private、protected）设立的，对于类的公开（public）属性，外面是可以直接访问与设置的（如：$p1->name），即不走__set()，__get()函数的！！！

2、在PHP5.3及以后，上述魔术方法（__get(),__set(),__isset(),__unset() 等）提倡是 public 类型的，并且不是 static 方法，否则会给出警告信息！

```
<?php
class A {
    private $name = 'qianyunlai';
    public $old = '26';
 
    private function __get($name) {
        echo $name, '<br />';
        return $this->$name;
    }
}
 
$a = new A();
print_r($a->name);
?>
```

![Warning](https://raw.githubusercontent.com/zhaoguibin/markdown_pic/master/10.__set()%EF%BC%8C__get()%EF%BC%8C__isset()%EF%BC%8C__unset()%E5%9B%9B%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8.jpg)

name  
qianyunlai